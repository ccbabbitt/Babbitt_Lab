---
title: "Pre-Filtering"
author: "Emily Miller"
date: "10/7/2022"
output: 
  pdf_document:
    includes:
      in_header: "wrap_text.tex"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = F, warning = F, tidy = T,
                      tidy.opts=list(width.cutoff=60))



library(tidyverse)
library(readr)
library(knitr) 
library(kableExtra)
```

```{r functions, echo = F}
#### I put all the f(x) at the top b/c otherwise markdown isn't happy - skip
get_mean<- function(dat, annotation_col=NULL, pattern = "^\\w*(?=\\dC$|C\\d$)",
                    col_ignore = NULL){
  if(!is.null(col_ignore)){
    bye <- dat %>% select(col_ignore)
    dat<- dat %>% select(-col_ignore)
  }
  if(!is.null(annotation_col)){
    #arrange the data so I can modify all columns easily
    mean_dat<- dat %>% 
      mutate(var = dat[[annotation_col]],# make a variable that I can manipulate
             rowid = row_number() #put rowid to make sure each row is uniquely ID'd
             ) %>% 
      select(-annotation_col) %>% #remove the original var bc it will get in the way
      pivot_longer(c(-rowid, -var)) %>% 
      #extract the species from the column names and store this in a new column
      mutate(group = str_extract(name, pattern))
    
    #take gene mean by species
    mean_dat<- mean_dat %>% 
      group_by(group, var, rowid) %>% 
      mutate(species_mean = mean(value)) %>% #take mean by species
      ungroup
    
    #reshape the data so each column is a mean of the individuals of each species
    mean_dat<- mean_dat %>% 
      select(-name, -value) %>% 
      rename(!!sym(annotation_col) := var) %>% #reassign the original colname 
      unique() %>% 
      pivot_wider(names_from = group, values_from = species_mean) %>% 
      select(-rowid) #in case this was also annotated
    
  } else { #just the repeat of the same code but without this column
      mean_dat<- dat %>% 
        mutate(rowid = row_number()) %>% 
        pivot_longer(-rowid) %>% 
        mutate(group = str_extract(name, pattern))

      #take gene mean by species
      mean_dat<- mean_dat %>% 
        group_by(group, rowid) %>% 
        mutate(species_mean = mean(value)) %>% 
        ungroup
      
      #reshape the data so each column is a mean of the individuals of each species
      mean_dat<- mean_dat %>% 
        select(-name, -value) %>% 
        unique() %>% 
        pivot_wider(names_from = group, values_from = species_mean) %>% 
        select(-rowid)
  }
  
  if(!is.null(col_ignore)){
    mean_dat<- bind_cols(mean_dat, bye)
  }
  
  #return the dataframe
  return (mean_dat)
  
}


filter_mean<- function(dat,  annotation_col = NULL, cutoff = 5, len = T){
  if(!is.null(annotation_col)){
    tempdat<-dat %>% 
      ungroup %>% 
      mutate(var = dat[[annotation_col]]) %>% 
      select(-annotation_col) %>% 
      filter(across(-var, ~abs(.)>=cutoff)) %>% 
      select(var) %>% 
      pull
  } else{
    #here i filter so all values are >=5 and grab their gene names
    tempdat<- dat %>% 
      ungroup %>% 
      #filter so everything >= cutoff
      #the warning here is that across() in filter is depreciated but it works
      filter(across(everything(), ~abs(.)>=cutoff))%>% 
      rowid_to_column(var = "rowid") %>% 
      select(rowid) %>%  # i assume that rownames have annotation
      pull
  }
  if(len){
    tempdat<- length(tempdat)
  }
  
  return(tempdat)
  
}


tmm_normalize<- function(dat, annotation_col = NULL, ref_col){
  if (!is.null(annotation_col)){ 
    #get rid of the annotation col so it doesn't cause problems with calcNormFactors
    byeCol<- dat %>% select(annotation_col)
    dat<- dat %>% select(-annotation_col) 
  }
  #normalize data
  dat<-dat %>% 
    mutate(across(everything(), ~replace_na(.,0)),
           across(everything(), ~as.numeric(.)))
  
  #get the colnumber of the column to be reference, so I can do below
  whichCol<- grep(ref_col, names(dat))
  
  #taken from EVEE/modified to fit with our variables
  scale = edgeR::calcNormFactors(as.data.frame(dat), refColumn = whichCol, method="TMM")
  scale = scale / scale[whichCol]
  data_mean.norm = sapply(seq(1, length(scale)), function(x) {dat[,x] / scale[x]})
  
  #combine the columns and log10
  temp<- do.call(cbind, data_mean.norm) %>% #converts this into df
   as_tibble() %>% 
    #i did log10 this way because r was being grumpy
   mutate(across(everything(), ~log10(.+0.01))) 
  
  temp<- bind_cols(byeCol, temp)
  
  return(temp)
}
```

## **Overview**
### The Script: ./scoreGenes.R

This script essentially compares a sample to a distribution and reports the z-score of your sample. It expects some inputs 

```{r scoregenes summary, echo = F, results='asis'}
# just a tibble explaning what you need as an input
tibble(input_name = c("ou_stats",
                      "ref_exp",
                      "test_sample"),
       description = c("the output of fitResiduals.R",
                       "the mean expression across all samples belonging to your species of interest",
                       "this is the population to compare to.. each column can represent the individual of the same or different species")) %>% 
  knitr::kable() %>% 
  kableExtra::kable_minimal() %>% 
  kableExtra::kable_styling(latex_options = "hold_position") %>% 
  kableExtra::column_spec(2, "10cm")
```

### The Problem
When running ./scoreGenes.R, the program keeps identifying low counts extreme outliers when in fact they may just be issues with matching orthologues. We need some way to filter genes that are lowly expressed before inputting into ./scoreGenes.R.

### This Script TLDR;
This script includes different ways to filter low counts and visualize filtering. There are 3 parts:

1. **Loading Data** - I go over how I take a raw matrix (like KR sent) and clean some data
2. **Filtering out 0s** - I use 2 methods: either by removing 0s from all samples, or removing samples after taking the mean of each species
3. **Finding Mean Cutoff Values** - I show you ways that I look at setting a cutoff with summary tables and a barchart
4. **Filtering Means Under a Cutoff** - This gives code for removing genes below a certain cutoff once you choose
4. **Export the Filtered Data** - I export the ref_species and test_ref dataframes to files to be used by EVEE
5. **Appendix** - Shows/explains the implementation of the functions I made for this.

## **Loading data**

These are the packages I'm using:

```{r library, eval = F}
library(tidyverse) #used for data manipulation
library(readr) #used to read in data
#library(kableExtra) #used to make pretty tables
#library(knitr) #used for making Rmarkdown
#library(gridExtra) #used for making multiple ggplots
```

First I'm loading in the data. Feel free to examine it in the viewer pane. I tried to load in the first column as rownames, but it said there were duplicates. I figure in your actual dataset that there won't be this kind of problem, so I am just renaming the column and ignoring it in my analysis. If you have a column you want to ignore (like gene names or annotations) you can just replace "gene" anywhere in the script with a vector (c()) of names you want to ignore.

```{r load data}
raw_dat <- read_delim("~/Desktop/honors398/all_C_raw.txt", 
                        delim = "\t", escape_double = FALSE, 
                        trim_ws = TRUE) %>% 
  rename(gene = `...1`) #renaming the gene anotation column as "gene"
```

Before doing anything, I want to make sure that there aren't any NA values, because those will make some downstream functions unhappy. 

```{r has NAs}
#if this = True, then you gotta replace NAs!
raw_dat %>% 
  select(-gene) %>% 
  pivot_longer(everything()) %>% 
  count(is.na(value))

##use this to replace NAs with 0s
# raw_dat<-raw_dat %>% mutate(across(-gene, ~replace_na(0)))
```

## **Filtering out 0s**
### Method 1: Make the ref_species column, then Remove 0s

We first want to make our "ref_exp", the reference column, which is the mean expression of all individuals of a species. I want to make this first because later we are going to filter the whole matrix so no columns have 0 counts. By making ref_exp first, we might reduce the number of genes we remove (because I assume that taking the mean will remove a few 0s). I am also keeping all of the columns in the same dataframe until the end because I assume that EVEE wants all the columns to be the same length.

```{r make H mean col}
#make ref_exp/take the mean of a set of species. 
dat<- raw_dat %>% 
  rowwise %>% #calculate mean by row, not by col
  # make a new column and take the mean of the 3 columns of interest
  mutate(H_mean = mean(c(H1C, H2C, H3C, na.rm = T), 
                       #na.rm=T if there are NAs this will make mean() unhappy
                       na.rm = T)) %>% 
  #remove the columns that I used to take the mean. I'm removing cols that match
  # a pattern H{number}C. you can alternatively write (you can uncomment below)
  #select(-H1C, -H2C, -H3C) #or whatever cols you want to remove
  #just make sure to put "-" in front of the colnames to get rid of them!
  select(-matches("H\\dC")) %>% 
  ungroup #no longer go by row
```

This removes rows in which any column contains a 0.
```{r replace 0s }
dat1<- dat %>% 
  filter(across(-gene, ~!.==0))
```

### Method 2: Take the mean of each species then remove 0s

Another ways is by taking the mean expression level of each species, then remove values that equal 0. If all individuals in a species have 0 cpm, I would assume it's probably more likely to be an alignment issue. The code below does this:

```{r replace 0s 2}
temp<- dat %>% 
  #returns a matrix where the mean is taken for all individuals of a species
  get_mean(., annotation_col = "gene") %>%  ### see the appendix for implementation details
  #removes rows that do not equal a cutoff, then returns the list of genes
  filter_mean(., annotation_col = "gene",cutoff = 0, F) ### see the appendix for implementation 

#remove the genes that did not make the cutoff
dat1<- dat %>% 
  filter(gene %in% temp)
```

## **Finding Mean Cutoff Values**

### Making the dataset for visualization

I want to see what will happen if we use the data with 0 filtered out before or after taking the mean of the individuals in each species. I also want to see what happens if we use different cutoffs. I expect we're most interested in setting a cutoff that is <10cpm. I'm therefore testing a series of cutoffs, 1-10, then 10-100 where we step by 10 each time. You can change these values! The dataframe (comp2) contains the results of this information.

```{r make before after datasets}
#make a series of cutoffs-- change these if you want to see others!
quants <- c(0:9, seq(10, 100, 10))
#this is for tmm normalized data because it's on a different scale
tmmquants <- seq(0, 4, .20)

#make tmm normalized data
comp<- dat %>% 
  nest(before = everything()) %>% 
  mutate(after = before,
         across(everything(), .fns = list(tmm = ~map(., ~tmm_normalize(., annotation_col = "gene", ref_col = "H_mean"))))) 

#reshape data so we can work with before/after
comp1<-comp %>% 
  pivot_longer(everything()) %>% 
  separate(name, c("when_filter", "tmm"), sep = "_") %>% 
  mutate(tmm = ifelse(is.na(tmm), "notmm", tmm)) %>% 
  pivot_wider(names_from = when_filter, values_from = value)

#get the mean before and after
comp2<- comp1 %>% 
  mutate(before = map(before, . %>% 
                        filter(across(-gene, ~!.==0)) %>% 
                        get_mean(., annotation_col = "gene", col_ignore = "H_mean")),
         after = map(after, . %>% 
                       get_mean(., annotation_col = "gene", col_ignore = "H_mean") %>% 
                       filter(across(-gene, ~!.==0))))

#make a temporary variable that has different quantile cutoffs to bind
temp<- tibble(cutoffs = quants) %>% nest %>% 
  bind_rows(., tibble(cutoffs = tmmquants) %>% nest)

#add cutoff and calculate
comp3<- comp2 %>% 
  bind_cols(., temp) %>% 
  unnest(data) %>% 
  pivot_longer(c(before, after), names_to = "when_filter") %>% #reshape
  mutate(val = map2(.x=value, .y=cutoffs, ~filter_mean(.x, cutoff = .y, "gene"))) %>% 
  unchop(val)

```

### Looking at Z-scores

In order to make sure that our samples don't have anything strange going on, we can visualize the Z-scores of our TMM-normalized counts.

```{r zscores}
# make a different dataset for graphing. 
zscores<-comp2 %>% 
  filter(tmm == "tmm") %>%  #only do this for tmm datasets
  #put when_filtered in the same column and make sure no duplicate rows (ex: 2xbefore)
  pivot_longer(c(before, after), names_to = "when_filter") %>% unique %>% 
  mutate(value = map(value, . %>% 
                       #input here columns that you want to ignore--here gene annotations
                       select(-gene) %>% 
                       scale %>% #calculates zscore
                       as_tibble))#scale returns a matrix so convert to tibble

#clean up the dataset to make graphing easier
zscores<- zscores %>% 
  mutate(value = map(value, . %>% #for making groups
                       pivot_longer(everything(), names_to = "species", 
                                    values_to = "zscore")),
         #just clean up tmm column to make it prettier for graphing
         tmm1 = ifelse(tmm == "tmm", "TMM-Normalized Means", "Means"),
         #this makes graph title labels nice and pretty
         plot_label = paste0("Z-score Distributions of Counts (0s removed ", 
                             when_filter," taking ", tmm1))

#use ggplot to make facet graphs of each
zscores1<- zscores %>% 
  mutate(plot_facet = map(value, ~ggplot(data = .x, aes(x = zscore))+ #count zscores
         #you can change bin width below if wanted, but it'll take longer to plot
                      geom_histogram() + 
           #this makes it so each species gets its own hist
                      facet_wrap(species ~.)))

#uncomment this if you want each to be plotted in real time
# zscores1 %>% mutate(plot_facet = map2(.x = plot_facet, .y = plot_label, ~gridExtra::grid.arrange(., top = .y)))


#if you want a specific one, uncomment below
# zscores1 %>% 
#   filter(when_filter == "before" & tmm == "tmm") %>% ##change this to change plot
#   mutate(plot_facet = map2(.x = plot_facet, .y = plot_label, ~gridExtra::grid.arrange(., top = .y)))

#here's some colorful overlayed plots
zscores1<-zscores1 %>% 
  mutate(plot_overlay = map2(value,plot_label, ~ggplot(data = .x, aes(x = zscore, fill = species))+
                              geom_histogram(alpha = 0.3)+
                               ggtitle(.y)))

# #print to screen
# lapply(zscores1$plot_overlay, function(x) x)

# zscores1[[7]][[1]]
```

### Visualizing: Summary Table

The following table shows how many genes are removed if their expression is below a certain value. This value I call "cutoff" The 2 columns refer to whether 0s were removed before or after the mean of each species is taken. Removing 0s before taking the mean removes about 1/3 of the dataset.

```{r}
#make a new dataframe with number of genes lost with each filtration step
tab_genes<- comp3 %>% 
  #get the total number of genes that there were to begin with
  mutate(tot = map(value, ~nrow(.))) %>% unnest(tot) %>% 
  #this makes 2 new columns, 1 with the number of genes removed and the
  # other is the % of genes removed
  mutate(n = tot - val,
         percent = round(abs(1-val/tot)*100, digits = 1), 
         #format percents so they look pretty
         n = paste0(n, " (", percent, "%)"))
   
# transform data to be pretty
tab_genes<- tab_genes %>% 
  #choose only columns that we're going to graph with
  select(tmm, when_filter, cutoffs, n) %>% 
  arrange(desc(when_filter), cutoffs) %>% #arrange so columns are in order
  pivot_wider(names_from = c(when_filter), values_from = n) #reshape data
  
#now to put 2 tables side by side, I need to split them before putting them in kable
tab_genes1<- tab_genes %>% 
  group_by(tmm) %>% 
  #just make col names/values readible 
  mutate(tmm = ifelse(tmm != "tmm", "No TMM", "TMM")) %>% 
  rename(`Normalization?` = tmm, 
         `Cutoff` = cutoffs,
         `n (Before Mean)` = before,
         `n (After Mean)` = after
         ) %>% 
  group_split() 

#format the table for the output
kable(tab_genes1, 
      # col.names = c("Normalization?","Cutoff at Mean", "n (0s Removed Before Taking Mean)",
      #        "n (0s Removed After Taking Mean)"),
    caption = "Number of Genes Removed at a Cutoff") %>% 
  #merge cells that are duplicates
  collapse_rows() %>% 
  #this makes it so the table doesn't show up in the middle of another codechunk
  kableExtra::kable_styling(latex_options = "hold_position") 

```

### Visualizing: Barchart

A barchart is a nice visual comparison of how much data are removed using different cutoffs. I am plotting TMM and non-TMM cutoffs seperately because I didn't feel like fighting with ggplot and using a facet_grid(). I don't make the x-axis proportional to the cutoff-values for the non-TMM normalized data because I didn't feel like fighting with ggplot.

```{r}
#make an overall dataset
plot_dat<- comp3 %>% 
  select(-value) %>% #rm nested data (takes up extra memory)
  #for aesthetics- just makes the legend more readable
  mutate(when_zeros_removed = ifelse(str_detect(when_filter, "after"), 
                                     "after mean(species)", 
                                     "before mean(species)"),
         #aesthetics --make titles for each plot
         tmm = ifelse(tmm == "tmm", "TMM-Normalized Species Means",
                      "Species Means"),
         plot_label = paste0(tmm, ": Counts vs. Library Size")) %>% 
  #make these datasets seperate so that way the cutoffs won't be plotted strangely
  group_by(plot_label, tmm) %>% 
  nest

#make the cutoffs pretty
plot_dat<-plot_dat %>% 
  mutate(data = map(data, . %>% 
          #cutoffs is our y-axis, and by turning this column into character values
         # this lets me graph these more easily (I'm being lazy here)
                      arrange(cutoffs) %>% 
                      mutate(cutoffs = as.character(cutoffs),
                             cutoffs = factor(cutoffs, levels = unique(cutoffs)))))
#make ggplots
plot_dat<- plot_dat %>% 
  mutate(plot = map2(data, plot_label, ~ggplot(.x, aes(x = cutoffs, y = val,
                    color = when_zeros_removed, fill = when_zeros_removed))+ #aesthetics
                      geom_bar(stat = "identity", #tells geom_bar to use val nums for y-axis
                               position = position_dodge2(preserve = "total"))+ #centers
                      xlab("Cutoff") + ylab("Library Size")+
                      ggtitle(.y)))

# #print to screen
lapply(plot_dat$plot, function(x) x)

# plot_dat[[4]][[2]]
```

## **Filtering Means Under a Cutoff**

Once we decide what cutoff to use, you can use this code to filter your dataset.

```{r}
#get a list of genes where the mean species expression is below a cutoff (I chose 5 here) 
temp<- dat1 %>% 
  get_mean(., "gene") %>% 
  filter_mean(., annotation_col="gene", 
              cutoff = 5, #change cutoff to a value that you think is appropriate!
              len= F)

#filter only genes that are in this column
dat2<- dat1 %>% 
  filter(gene %in% temp)
```

## **Export the Filtered Data**

We can save the filtered data to files that can be used by EVEE. Feel free to modify this code to what you need!

```{r, eval = F}
#label whether columns are the test_ref or the ref_species
out<- dat2 %>% 
  rowid_to_column() %>% 
  pivot_longer(c(-gene, -rowid)) %>% 
  #This labels certain columns as the reference species. 
  #Change ({code} ~ "{this text}",) to change the file names
  #Change str_detect(name, "{this text}") to change which col is selected as 
  # the ref species
  mutate(group_cols = case_when(
    str_detect(name,"_mean") ~ "ref_species",
    T~ "test_ref"
  )) %>% 
  #store each set of columns as a dataframe inside the main dataframe
  group_by(group_cols) %>% 
  nest() %>% 
  ungroup

#pivot out the data so we have the data stored as columns again
out<- out %>% 
  mutate(data = map(data, . %>% 
                      pivot_wider(names_from = "name", values_from = "value") %>% 
                      ##uncomment the line below if your rownames are gene names
                      # column_to_rownames("rowid") %>% 
                      ##comment out the lines below if you uncomment the line above^^
                      select(-rowid) %>% 
                      column_to_rownames("gene")))

#write these to files -- make sure to set your working dir to where you want
# setwd("/Users/emmanuelmiller/Desktop")
map2(.x = out$group_cols, .y = out$data, 
     ~write.table(.y, file = paste0(.x, ".txt"), sep="\t", quote=F))

```


## **Appendix**

get_mean calculates the mean expression values of all individuals of a species. This function allows you to specify if you have a column with annotated genes or not in the parameter "annotation_col". The pattern argument is used in order to find which columns are of the same species--I can change this if you'd rather input the index. Finally, I included col_ignore in case you want to ignore any additional columns in the dataset. The code in the if-statements is identical except for the first code chunk is able to take in this column. 

```{r, eval = F}
#' get_mean calculates the mean expression values of all individuals of a species
#' 
#' @param dat dataframe with individual samples
#' @param annotation_col column containing gene annotations (will be ignored in calulations)
#' @param pattern regex pattern used to extract the species from each colname
#' @param col_ignore string specifying any additional columns to ignore
#' @return dataframe where each column is the mean expression of each species
#### I put all the f(x) at the top b/c otherwise markdown isn't happy - skip
get_mean<- function(dat, annotation_col=NULL, pattern = "^\\w*(?=\\dC$|C\\d$)",
                    col_ignore = NULL){
  if(!is.null(col_ignore)){
    bye <- dat %>% select(col_ignore)
    dat<- dat %>% select(-col_ignore)
  }
  if(!is.null(annotation_col)){
    #arrange the data so I can modify all columns easily
    mean_dat<- dat %>% 
      mutate(var = dat[[annotation_col]],# make a variable that I can manipulate
             rowid = row_number() #put rowid to make sure each row is uniquely ID'd
             ) %>% 
      select(-annotation_col) %>% #remove the original var bc it will get in the way
      pivot_longer(c(-rowid, -var)) %>% 
      #extract the species from the column names and store this in a new column
      mutate(group = str_extract(name, pattern))
    
    #take gene mean by species
    mean_dat<- mean_dat %>% 
      group_by(group, var, rowid) %>% 
      mutate(species_mean = mean(value)) %>% #take mean by species
      ungroup
    
    #reshape the data so each column is a mean of the individuals of each species
    mean_dat<- mean_dat %>% 
      select(-name, -value) %>% 
      rename(!!sym(annotation_col) := var) %>% #reassign the original colname 
      unique() %>% 
      pivot_wider(names_from = group, values_from = species_mean) %>% 
      select(-rowid) #in case this was also annotated
    
  } else { #just the repeat of the same code but without this column
      mean_dat<- dat %>% 
        mutate(rowid = row_number()) %>% 
        pivot_longer(-rowid) %>% 
        mutate(group = str_extract(name, pattern))

      #take gene mean by species
      mean_dat<- mean_dat %>% 
        group_by(group, rowid) %>% 
        mutate(species_mean = mean(value)) %>% 
        ungroup
      
      #reshape the data so each column is a mean of the individuals of each species
      mean_dat<- mean_dat %>% 
        select(-name, -value) %>% 
        unique() %>% 
        pivot_wider(names_from = group, values_from = species_mean) %>% 
        select(-rowid)
  }
  
  if(!is.null(col_ignore)){
    mean_dat<- bind_cols(mean_dat, bye)
  }
  
  #return the dataframe
  return (mean_dat)
  
}
```

filter_mean returns the gene names where no columns have values below a certain cutoff. annotation_col is the annotated gene column that you can optionally put. Because I use this so much for figuring out how many genes are retained, the "len" argument returns the number of genes retained.

```{r, eval = F}
#' filter_mean returns the gene names where no columns have values below a certain cutoff
#' 
#' @param dat dataframe with individual samples
#' @param annotation_col column containing gene annotations (will be ignored in calulations)
#' @param cutoff number that samples in a given row should be the same
#' @param len boolean, should the function return the number of genes retained? F = just gene names
#' @return if len=F, the function returns a character vector of gene names where no columns have values below the cutoff
filter_mean<- function(dat,  annotation_col = NULL, cutoff = 5, len = T){
  if(!is.null(annotation_col)){
    tempdat<-dat %>% 
      ungroup %>% 
      mutate(var = dat[[annotation_col]]) %>% 
      select(-annotation_col) %>% 
      filter(across(-var, ~abs(.)>=cutoff)) %>% 
      select(var) %>% 
      pull
  } else{
    #here i filter so all values are >=5 and grab their gene names
    tempdat<- dat %>% 
      ungroup %>% 
      #filter so everything >= cutoff
      #the warning here is that across() in filter is depreciated but it works
      filter(across(everything(), ~abs(.)>=cutoff))%>% 
      rowid_to_column(var = "rowid") %>% 
      select(rowid) %>%  # i assume that rownames have annotation
      pull
  }
  if(len){
    tempdat<- length(tempdat)
  }
  
  return(tempdat)
  
}

```

Finally, I made a function for TMM-normalization. I borrowed some code from EVEE because Jenny usually TMM-normalizes in this code. For scoreGenes.R, she doesn't log10 the counts, which I did do for this data. There is an option not to log10. 
```{r, eval = F}
#' TMM-normalizes all columns in a dataframe
#' @param dat dataframe with individual samples
#' @param annotation_col column containing gene annotations (will be ignored in calulations)
#' @param ref column name of reference species to be normalized to
#' @param log10 boolean, should data be log10 transformed after normalization? T = yes
#' @return dataframe of tmm normalized counts
tmm_normalize<- function(dat, annotation_col = NULL, ref_col, log10=T){
  if (!is.null(annotation_col)){ 
    #get rid of the annotation col so it doesn't cause problems with calcNormFactors
    byeCol<- dat %>% select(annotation_col)
    dat<- dat %>% select(-annotation_col) 
  }
  #normalize data
  dat<-dat %>% 
    mutate(across(everything(), ~replace_na(.,0)),
           across(everything(), ~as.numeric(.)))
  
  #get the colnumber of the column to be reference, so I can do below
  whichCol<- grep(ref_col, names(dat))
  
  #taken from EVEE/modified to fit with our variables
  scale = edgeR::calcNormFactors(as.data.frame(dat), refColumn = whichCol, method="TMM")
  scale = scale / scale[whichCol]
  data_mean.norm = sapply(seq(1, length(scale)), function(x) {dat[,x] / scale[x]})
  
  #combine the columns and log10
  temp<- do.call(cbind, data_mean.norm) %>% #converts this into df
   as_tibble()
  
  if(log10){
    #i did log10 this way because r was being grumpy
    temp<-temp %>% mutate(across(everything(), ~log10(.+0.01))) 
  }
  
  if(!is.null(annotation_col)){
    temp<- bind_cols(byeCol, temp)
  }
  
  return(temp)
}
```


If it's helpful for you to walk through what each section of the above functions looks like, here is some code you can walk through. I find it helpful to use the viewer to see what each part modifies.

```{r, eval = F}
#sets up so that way I can get gene mean by species
mean_dat<- dat %>% 
  rowid_to_column() %>% 
  pivot_longer(c(-gene, -rowid)) %>% 
  mutate(group = str_extract(name, "^\\w*(?=\\dC$|C\\d$)"))

#take gene mean by species
mean_dat<- mean_dat %>% 
  group_by(group, gene, rowid) %>% 
  mutate(species_mean = mean(value)) %>% 
  ungroup

#reshape the data so each column is a mean of the individuals of each species
mean_dat<- mean_dat %>% 
  select(-name, -value) %>% 
  unique() %>% 
  pivot_wider(names_from = group, values_from = species_mean) %>% 
  select(-rowid)

#here i filter so all values are >=5 and grab their gene names
tempdat<- mean_dat %>% 
  filter(across(-gene, ~.>=5)) %>% #filter so everything >= 5
  select(gene) %>% 
  pull

# filter the raw data so that 
dat2<- dat1 %>% 
  filter(gene %in% tempdat)
```
